#!/usr/bin/guile --no-auto-compile 
!#

(use-modules (watch add)
             (watch play)
             (watch list)
             (watch remove)
             (watch set)
             (ice-9 getopt-long))

(define (main args)
  (let* ((general-option-spec '((version (single-char #\v) (value #f))
                                (help    (single-char #\h) (value #f))))
         (general-options (getopt-long args general-option-spec #:stop-at-first-non-option #t))
         (version-wanted  (option-ref general-options 'version #f))
         (help-wanted     (option-ref general-options 'help #f)))
    (if (or version-wanted help-wanted)
      (begin
        (if version-wanted
          (display-version))
        (if help-wanted 
          (display-help)))
      (let* ((stripped-args (option-ref general-options '() '()))
             ;; In case no arguments whatsoever were passed, 'command' will just slip 
             ;; through the 'case' and general help will be printed.
             (command (unless (null? stripped-args) (string->symbol (car stripped-args)))))
        (catch 
          #t
          ;; thunk
          (lambda ()
            (case command
              ((add) 
               (let* ((add-option-spec '((help             (single-char #\h) (value #f))
                                         (name             (single-char #\n) (value #t))
                                         (path             (single-char #\p) (value #t))
                                         (starting-episode (single-char #\s) (value #t))))
                      (add-options      (getopt-long stripped-args add-option-spec))
                      (help-wanted      (option-ref add-options 'help #f))
                      (name             (option-ref add-options 'name #f))
                      (path             (option-ref add-options 'path #f))
                      (starting-episode (option-ref add-options 'starting-episode "1")))
                 (cond 
                   (help-wanted 
                     (display-help 'add))
                   ((not (and name path))
                    (throw 'insufficient-args-exception
                           "insufficient arguments
Try 'watch add --help' for more information."))
                   (else 
                     (add-show-db name path (1- (string->number starting-episode)))))))
              ((play)
               (let* ((play-option-spec '((help        (single-char #\h) (value #f))
                                          (episode     (single-char #\e) (value #t))
                                          (set         (single-char #\s) (value #f))))
                      (play-options (getopt-long stripped-args play-option-spec))
                      (help-wanted  (option-ref play-options 'help #f))
                      (episode      (option-ref play-options 'episode #f))
                      (set-wanted   (option-ref play-options 'set #f))
                      ;; Here we get a list that should consist of one element
                      ;; which is the show name.
                      (show-name    (option-ref play-options '() '())))
                 (cond 
                   (help-wanted
                     (display-help 'play))
                   ;; If the list is empty then the required argument is missing.
                   ((null? show-name) 
                    (throw 'insufficient-args-exception
                           "missing show name
Try 'watch play --help' for more information."))
                   (episode 
                     (play-show-db (car show-name)
                                   #:increment? set-wanted 
                                   #:custom-episode-index (1- (string->number episode))))
                   (else 
                     (play-show-db (car show-name))))))
              ((list)
               (let* ((list-option-spec '((help (single-char #\h) (value #f))
                                          (long (single-char #\l) (value #f))))
                      (list-options       (getopt-long stripped-args list-option-spec))
                      (help-wanted        (option-ref  list-options 'help #f))
                      (long-format-wanted (option-ref  list-options 'long #f)))
                 (if help-wanted 
                   (display-help 'list)
                   (list-shows-db long-format-wanted))))
              ((remove)
               (let* ((remove-option-spec '((help (single-char #\h) (value #f))
                                            (over (single-char #\o) (value #f))))
                      (remove-options (getopt-long stripped-args remove-option-spec))
                      (help-wanted    (option-ref remove-options 'help #f))
                      (over-wanted    (option-ref remove-options 'over #f))
                      ;; Here we get a list that should consist of one element
                      ;; which is the show name passed as an argument.
                      (show-name      (option-ref remove-options '() '())))
                 (cond 
                   (help-wanted 
                     (display-help 'remove))
                   (over-wanted
                     (remove-over-db))
                   ;; If neither '--over' nor a show name were passed
                   ;; signal an error.
                   ((null? show-name)
                    (throw 'insufficient-args-exception
                           "insufficient arguments
Try 'watch remove --help' for more information."))
                   (else 
                     (remove-show-db (car show-name))))))
              ((set)
               (let* ((set-option-spec '((help            (single-char #\h) (value #f))
                                         (name            (single-char #\n) (value #t))
                                         (path            (single-char #\p) (value #t))
                                         (current-episode (single-char #\e) (value #t))
                                         (over            (single-char #\o) (value #f))))
                      (set-options         (getopt-long stripped-args set-option-spec))
                      (help-wanted         (option-ref set-options 'help #f))
                      (new-name            (option-ref set-options 'name #f))
                      (new-path            (option-ref set-options 'path #f))
                      (new-current-episode (option-ref set-options 'current-episode #f))
                      (over-wanted         (option-ref set-options 'over #f))
                      ;; Here we get a list that should consist of one element
                      ;; which is the show name passed as an argument.
                      (show-name           (option-ref set-options '() '())))
                 (cond
                   (help-wanted
                     (display-help 'set))
                   ;; This checks for the case where no show name was passed as an argument.
                   ((null? show-name)
                    (throw 'insufficient-args-exception
                           "insufficient arguments
Try 'watch set --help' for more information."))
                   (new-name
                     (set-show-name-db (car show-name) new-name))
                   (new-path
                     (set-show-path-db (car show-name) new-path))
                   (new-current-episode
                     (set-show-current-episode-db (car show-name) (string->number new-current-episode)))
                   (over-wanted
                     (set-show-current-episdoe-db (car show-name) 'over)))))
              (else
                (display-help))))
          ;; handler
          (lambda (key message)
            (die message)))))))

(define (die message)
  (format #t "watch: ~a~%" message)
  (exit 1))
(define* (display-help #:optional command)
  (case command
    ((add) 
     (display "\
Usage: watch add <required-options> [<options>]

required-options: 
    -n, --name <name>:                  show name, a unique identifier.
    -p, --path <path>:                  path to the directory that contains 
                                        episodes of the new show.
options:
    -s, --starting-episode <integer>:   number of the episode the new show will
                                        start playing from, default value: 1."))
    ((play)
     (display "\
Usage: watch play [<options>] <show> 

options:
    -e, --episode <integer>:    number of the episode to play instead of 
                                current episode.
    -s, --set:                  if specified together with '--episode' show
                                will continue to play from that specified episode
                                in the future."))
    ((list)
     (display "\
Usage: watch list [<options>]

options:
    -l, --long:     use a long listing format."))
    ((remove)
     (display "\
Usage: watch remove [<options>] [<name>...]

options:
    -o, --over:     remove all shows whose current episode == over."))
    ((set)
     (display "\
Usage: watch set [<options>] <name>

options:
    -n, --name <name>:                  set a new name.
    -p, --path <path>:                  set a new path.
    -e, --current-episode <integer>:    set current episode.
    -o, --over:                         set current episode = over."))
    (else 
      (display "\
Usage: watch [--version] [--help] <command> [<options>]

available commands:
    add:        add a show.
    play:       play a show.
    list:       list existing shows.
    remove:     remove shows.
    set:        modify a show.
    
See 'watch <command> --help' to learn more about a specific command.")))
  (newline))

(define (display-version)
  (display "watch version 0.1 alpha") (newline))

(main (command-line))

;; vim: filetype=scheme
